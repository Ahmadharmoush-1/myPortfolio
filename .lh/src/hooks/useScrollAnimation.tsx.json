{
    "sourceFile": "src/hooks/useScrollAnimation.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1755522698972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1755522698972,
            "name": "Commit-0",
            "content": "import { useEffect, useRef, useState } from 'react';\r\n\r\ninterface UseScrollAnimationOptions {\r\n  threshold?: number;\r\n  triggerOnce?: boolean;\r\n  rootMargin?: string;\r\n}\r\n\r\nexport const useScrollAnimation = (options: UseScrollAnimationOptions = {}) => {\r\n  const [isVisible, setIsVisible] = useState(false);\r\n  const elementRef = useRef<HTMLDivElement>(null);\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element) return;\r\n\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => {\r\n        if (entry.isIntersecting) {\r\n          setIsVisible(true);\r\n          if (options.triggerOnce) {\r\n            observer.unobserve(element);\r\n          }\r\n        } else if (!options.triggerOnce) {\r\n          setIsVisible(false);\r\n        }\r\n      },\r\n      {\r\n        threshold: options.threshold || 0.1,\r\n        rootMargin: options.rootMargin || '0px 0px -50px 0px',\r\n      }\r\n    );\r\n\r\n    observer.observe(element);\r\n\r\n    return () => {\r\n      observer.unobserve(element);\r\n    };\r\n  }, [options.threshold, options.triggerOnce, options.rootMargin]);\r\n\r\n  return { elementRef, isVisible };\r\n};\r\n\r\nexport const useStaggeredAnimation = (count: number, delay: number = 100) => {\r\n  const [visibleItems, setVisibleItems] = useState<boolean[]>(new Array(count).fill(false));\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => {\r\n        if (entry.isIntersecting) {\r\n          // Stagger the animation of items\r\n          for (let i = 0; i < count; i++) {\r\n            setTimeout(() => {\r\n              setVisibleItems(prev => {\r\n                const newState = [...prev];\r\n                newState[i] = true;\r\n                return newState;\r\n              });\r\n            }, i * delay);\r\n          }\r\n          observer.unobserve(container);\r\n        }\r\n      },\r\n      {\r\n        threshold: 0.1,\r\n        rootMargin: '0px 0px -50px 0px',\r\n      }\r\n    );\r\n\r\n    observer.observe(container);\r\n\r\n    return () => {\r\n      observer.unobserve(container);\r\n    };\r\n  }, [count, delay]);\r\n\r\n  return { containerRef, visibleItems };\r\n};"
        }
    ]
}